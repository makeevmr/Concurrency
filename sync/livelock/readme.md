# Livelock

## Пререквизиты

- [sync/deadlock](/tasks/sync/deadlock)

---

Дана [реализация спинлока](spinlock.hpp):

```cpp
class SpinLock {
 public:
  void Lock() {
    while (thread_count_.fetch_add(1) > 0) {
      thread_count_.fetch_sub(1);  // Step back
    }
  }

  void Unlock() {
    thread_count_.fetch_sub(1);
  }

 private:
  std::atomic<size_t> thread_count_{0};
};
```

Реализация использует RMW (_read_-_modify_-_write_) операции [fetch_add](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add) и [fetch_sub](https://en.cppreference.com/w/cpp/atomic/atomic/fetch_sub).

## Safety & Liveness

Нетрудно убедиться, что `SpinLock` гарантирует взаимное исключение (*safety*, □, *никогда не случается ничего плохого*): два потока
не могут одновременно находиться между вызовами `Lock()` и `Unlock()`<sup>†</sup>.

Но лишь не делать ничего плохого – мало. Помимо взаимного исключения, любой спинлок должен также гарантировать прогресс (*liveness*, ◇, *однажды случится что-то хорошее*<sup>★</sup>):
если несколько потоков хотят захватить свободный спинлок, то один из них обязательно завершит свой вызов `Lock()`.

### <sup>†</sup> Weak MM

Определение свойства «взаимное исключение» дано в модели [Sequential Consistency](https://jepsen.io/consistency/models/sequential). После перехода к
слабым моделям памяти будет полезно вернуться к нему и переформулировать в терминах частичных порядков С++ MM.

## Livelock

В этой задаче вам нужно построить исполнение, в котором потоки бесконечно долго не могут захватить свободный `SpinLock`. Иначе говоря, вам нужно завести потоки в _лайвлок_ (_livelock_).

## Fairness

В этой задаче вы играете за планировщик, и должны делать это _честно_ (свойство _fairness_): в построенном вами бесконечном исполнении каждый поток должен получать управление бесконечно много раз.

## <sup>★</sup> Темпоральная логика

Формальные определения _safety_, _liveness_ и _fairness_ вы можете найти в книге [A Science of Concurrent Programs](https://lamport.azurewebsites.net/tla/science.pdf) [Лесли Лэмпорта](https://en.wikipedia.org/wiki/Leslie_Lamport).

## Симуляция

Мы вновь воспользуемся [_TinyFiber_](https://gitlab.com/Lipovsky/tinyfiber).

В файле [`sim.cpp`](sim.cpp) вы найдете код детерминированной симуляции, в которой потоки (вернее, уже знакомые вам файберы) в цикле выполняют критические секции. 

Внутри этого цикла дана развертка методов `Lock` и `Unlock` класса `SpinLock`, а также тело критической секции.

Вы должны вставить в тело цикла переключения потоков (вызовы функции `Yield`) таким образом, чтобы потоки вошли в лайвлок. 

Разрешается вставлять только единичные вызовы `Yield`, писать новые циклы и условную логику нельзя.

Файл [`spinlock.hpp`](spinlock.hpp) менять не нужно, он дан лишь для знакомства с алгоритмом.

## Тестирование

Прежде чем решать задачу, разберитесь как тест проверят наличие лайвлока в исполнении.
