# Мьютекс

Отличие _мьютекса_ от _спинлока_ проявляется в ситуации _contention_, когда сразу несколько потоков одновременно пытаются завладеть блокировкой: 

- В _спинлоке_ ждущий поток _кружится_ (_spinning_) на ядре процессора до тех пор, пока не получит владение блокировкой,
- В _мьютексе_ ждущий поток _блокируется_ <sup>†</sup> (_blocking_), т.е. уходит с ядра процессора в системную очередь ожидания.

## Задание

Реализуйте [`Mutex`](mutex.hpp) ~ [std::mutex](https://ru.cppreference.com/w/cpp/thread/mutex).

### Требования к реализации

* Если поток не может захватить мьютекс, потому что его опережают другие потоки, то он должен запарковаться на фьютексе и освободить ядро процессора.
* Если contention-а нет, то захват и освобождение мьютекса должны выполняться без переключения в ядро операционной системы, т.е. без выполнения системных вызовов.

## Futex

Блокировка пользователя реализуется в ядре операционной системы, остановить / запланировать поток может только _планировщик_ ОС.

Для блокировок операционная система (точнее, _Linux_) предоставляет пользователю специальный механизм – _futex_.

Futex – ядерная очередь спящих потоков, которая привязана к ячейке памяти в адресном пространстве пользователя.

Пользователь работает с фьютексом через одноименный системный вызов – [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html).

Обратите внимание: `futex` работает только с 32-битными ячейками памяти.

### References

- [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html)
- [kernel/futex/waitwake.c](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c)

### Гарантии

Конкурирующие вызовы `futex` будут атомарны относительно друг друга: в ядре при работе с очередью фьютекса берется спинлок.

При этом вызов `futex` в режиме `FUTEX_WAIT` не будет атомарным относительно записи в ячейку памяти из другого потока: запись может выполниться между чтением значения и парковкой потока в системном вызове.

Прочтите [Basic futex operation and ordering guarantees](https://github.com/torvalds/linux/blob/master/kernel/futex/waitwake.c) и пробегитесь по реализации, это **единственный** надежный способ разобраться в гарантиях `futex`.

### Другие OS

Выше мы говорили про конкретную операционную систему – Linux.

Другие операционные системы предоставляют собственные (похожие, но не идентичные по семантике) системные вызовы: Windows – `WaitOnAddress`, Darwin – `ulock_wait`.


## `twist::ed::futex`

Мы будем работать с системным механизмом ожидания через API `twist/ed/wait/futex.hpp`:

- [API](https://gitlab.com/Lipovsky/twist/-/blob/master/docs/ru/twist/ed/wait/futex.md)
- [Пример использования](https://gitlab.com/Lipovsky/twist/-/blob/master/examples/futex/main.cpp)

### Отличия от системного вызова `futex`

Обозначим через `SysWait` и `SysWake` системные вызовы для блокирующего ожидания и пробуждения (например, `futex` режимах `FUTEX_WAIT` и `FUTEX_WAKE` в случае Linux).

`futex::Wait` оборачивает вызов `SysWait` в цикл с перепроверкой условия:

```cpp
void Wait(std::atomic<uint32_t>& atom, uint32_t old) {
  while (atom.load() == old) {
    SysWait(Addr(atom), old);
  }
}
```

Этот дополнительный цикл сглаживает разницу в семантике между механизмами ожидания в разных операционных системах.

`Wake` – двухфазный:

1) Сначала (_до_ записи в атомик, которая предшествует пробуждению) с помощью `PrepareWake` фиксируется ключ (`WakeKey`) для адресации системной очереди ожидания для атомика (фактически – адрес ячейки памяти):

```cpp
WakeKey PrepareWake(std::atomic<uint32_t>& atom) {
  return {Addr(atom)};
}
````

2) Затем (_после_ записи в атомик) вызывается `SysWake` с адресом, который был взят на первом шаге:

```cpp
void WakeOne(WakeKey key) {
  SysWake(key.addr, 1);
}
```

### Ограничения

Фьютекс работает только с 32-битными словами в пространстве пользователя, так что `Wait` поддерживает только `atomic<uint32_t>`.

## <sup>†</sup> Адаптивность

Реализация может действовать _адаптивно_: сначала оптимистично покрутиться на ядре процессора, и только потом парковаться в ядре операционной системы.

См. метод [`ConsiderParking`](https://gitlab.com/Lipovsky/twist/-/blob/master/docs/ru/twist/ed/wait/spin.md?ref_type=heads#considerparking) у `twist::ed::SpinWait`.

## `TWIST_MODEL`

[Тесты](tests/model.cpp) типа [`TWIST_MODEL`](/library/testing/README.md) перебирают все чередования с заданным количеством вытеснений. Чем эффективнее
ваше решение, тем меньше исполнений потребуется исследовать при тестировании.
